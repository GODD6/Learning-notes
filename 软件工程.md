# 软件工程（软件+文档：技术+管理）

## --软件危机

软件开发维护过程中遇到的一系列严重的问题

### 典型表现

1.对开发成本和进度估计不准确

2.用户对以完成的软件不满意

3.质量靠不住：质量检测要应用到开发的全过程

4.可维护性差：开发时没有考虑到

------



## --软件工程方法学（范型）

#### 方法

完成各项任务的技术方法

#### 工具

为方法提供的支持环境

#### 过程

开发框架：规定了工作的步骤

#### 主要方法学

##### 传统方法学（面向行为或面向数据）

结构化技术来完成，一个阶段一个阶段的完成

##### 面向对象方法学（行为与数据同意重要）

1.任何元素都是对象，用对象分解了传统的功能方法

2.对象划分为类，每个类都定义了数据（静态属性）和操作（动态行为）

3.父子类之间的继承

4.对象之间可以互相通信

------



## --软件的生命周期

定义+开发+维护

### 可行性研究

解决的问题是什么，有没有解决的办法。

给出问题定义报告，目标，可行性研究报告（经济，技术，操作，社会），项目开发计划（粗略的计划）

### 需求分析

目标系统必须做什么？

完整，具体的需求分析。

给出**需求分析文档**，需求规格说明书

### 总体设计

根据需求分析的结果设计实现方案

给出总体设计说明书

### 详细设计

设计每个模块的**算法和数据结构**

给出详细设计说明书

### 实现与单元测试

选择语言，编码，测试模块

给出程序清单和单元测试报告

### 综合测试

将单元测试组装起来进行集成测试

确认测试：用户根据需求规格说明书来测试

### 使用与维护

必要的维护满足用户日常的使用要求：改正性，适应性，完善性，预防性维护

------



## --软件过程模型

开发过程的框架，又叫生命周期模型

### （1）瀑布模型

![image-20200523163115519](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523163115519.png)

==三个特点==

1.阶段之间具有**顺序性和依赖性**

2.推迟实现：分析设计工作做好，尽可能推迟程序的实现

3.质量保证:(1)每个阶段都要给出规定的文档

​				（2）每个阶段的结束都要对文档进行评审

==缺点==

1.软件交付之前只能通过**文档**给用户看

2.如果犯错了很难实现修改(加入反馈环，允许回去改错)

3.缺乏灵活性，最开始的需求往往不完整

### （2）快速原型模型（需求不确定的系统）

快速建立符合用户初始要求的**原型系统**，反复给用户修改

![image-20200523163920920](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523163920920.png)

==优点==

1.确定需求要优于瀑布

2.提供给用户的学习手段

3.原型可能成为最后系统的一部分

==缺点==

内部结构可能不好，因为是快速建立起来的

### 增量模型（渐增模型）

![image-20200523164148380](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523164148380.png)

把系统作为**构件**来设计编码测试，提交一个个的构件给用户

==优点==

1.较短的时间内向用户提交

2.用户有充裕的时间来学习适应

3.软件构件开放，便于后续的构件添加（做到这点很难）

### （3）螺旋模型（加入风险分析）

![image-20200523164643793](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523164643793.png)

![image-20200523164744314](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523164744314.png)

四个项目一个循环，不断的重复新增需求

==优点==

对于大型项目可以很好的控制风险

==缺点==

1.需要风险评估的经验

2.不适应现在大部分软件

### （4）喷泉模型

**面向对象**生命周期，**迭代（系统某部分重复工作逐渐加入到系统）和无缝（分析设计编码没有明显的边界）**

![image-20200523165213157](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523165213157.png)

一个圆是一个阶段

==优点==

分析设计同步做，提高效率

==缺点==

文档管理困难

### （5）RATIONAL统一过程（二维生命周期）

![image-20200523165358210](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200523165358210.png)

**4各阶段**：

初始阶段:建立业务模型,定义最终产品视图,并确定项目的范围

精化阶段:设计并确定系统的体系结构,制定项目计划确定资源需求

构建阶段:开发出所有构件和应用程序,把它们集成客户需要的产品,并且详细地测试所有功能

移交阶段:把开发出的产品提交给用户使用

**9个核心：**

业务建模:深入了解使用目标系统的机构及商务运作评估目标系统对使用它的机构的影响

需求:捕获客户的需求并且使开发人员和用户达成对需求描述的共识

分析与设计:把需求分析的结果转化为分析模型和设计模型

实现:把设计模型转化为实现结果

测试:检查各子系统的交互与集成,验证所有需求是否都被正确实现,识别,确认缺陷并确保在软件部署之前消除缺陷

部署:成功生成目标系统的可运行版本,并将软件移交给用户

配置与变更管理:跟踪并维护在软件过程中产生的所有制品的完整性和一致性

项目管理:提供项目管理框架,为软件开发制定计划,人员配备,执行和监控等方面的使用准则,并为风险管理提供框架

环境:向软件开发机构提供软件开发环境,包括过程管理和工具支持

**迭代开发，不断有新的版本发布，有一整套的环境和开发工具**

### （6）微软过程模型（适用于商业环境）

划分为5个阶段，类似螺旋模型：

1.规划阶段

2.设计阶段：确定大部分需求就可以开始设计‘

3.开发阶段

4.稳定阶段：测试和调试

5.发布阶段

### （7）敏捷过程和极限编程

#### 敏捷过程

1. 个体和交互胜过过程和工具**（团队沟通合作）**
2.  可以工作的软件胜过面面俱到的文档**（文档也需要，但是主要还是软件）**
3. 客户合作胜过合同谈判**（注重交流而不是合同）**
4. 响应变化胜过遵循计划**（计划赶不上变化）**

#### 极限编程

- 良好的工作环境
- 客户作为开发团队的一员
- 基于测试驱动开发周期
- 结对编程
- 写程序之前写测试单元，不断的测试

------



## --结构化分析

### -可行性研究

以最小的代价确定问题是否被解决

#### **可行性研究过程**

- 复查系统规模和目标
- 研究正在使用的系统
- 导出新系统的高层逻辑模型
- 进一步定义问题
- 导出和评价供选择的解法
- 推荐行动方针
- 草拟开发计划
- 书写文档提交审查

#### **系统流程图**（物理数据流图）

是概括地描绘物理系统的传统工具。用图形符号以黑盒子形式描绘组成系统的每个部件（程序，文档，数据库，人工过程等）。表达的是**数据在系统各部件之间流动的情况**，是一个**物理过程**。

|        符号         |   名称   |                             说明                             |
| :-----------------: | :------: | :----------------------------------------------------------: |
|        矩形         |   处理   | 能改变数据值或数据位置的加工或部件。如程序 、处理机、人工加工等都是处理 |
|     平行四边形      | 输入输出 |       表示输入或输出，是一个广义的不指名具体设备的符号       |
|        圆形         |   连接   |   指出转到图的另一部分或从图的另一部分转来，通常在同一页上   |
| 矩形下面 加个三角形 | 换页连接 |               指出转到另一页图上或另一页图转来               |
|        箭头         |  数据流  |              用来连接其他符号，指明数据流的方向              |

#### 数据流图

是一种图形化技术，它描绘信息流和数据从输入移动到输出移动的过程中所经受的变换。是系统逻辑功能的图形表示。是一个**逻辑过程**。

|             图形             |         说明         |
| :--------------------------: | :------------------: |
|        正方形或立方体        |   数据的源点/终点    |
|        圆角矩形或圆形        |    变换数据的处理    |
| 矩形缺了右边一条边或平行双线 | 数据存储（静态数据） |
|             箭头             |  数据流（动态数据）  |
|              *               |          与          |
|              +               |          或          |
|              ⊕               |     互斥（异或）     |

#### 数据字典

是关于数据的信息集合，也就是对数据流图中包含的所有元素的定义的集合。由四类元素定义组成：`数据流` `数据流分量（即数据元素）` `数据存储` `处理`。

**数据字典+数据流图=逻辑模型**

#### 成本效益分析

从经济角度判断是否可行。

三种方法：

- 代码行技术：软件成本=每行代码的平均成本*估计的源代码总行数

- 任务分解技术：单本任务成本=任务所需人力估计值*每人每月平均工资；软件开发项目总成本=每个单独任务成本估计总和

- 自动估计成本技术：采用自动估计成本的软件

  ------

  

### -需求分析

4个准则

1. 理解信息域，建立数据模型(e-r图)
2. 定义软件功能，建立功能模型(数据流图)
3. 描述软件行为，建立行为模型（状态转换图）
4. 分解三个模型，按层次展示细节

#### 需求分析的任务

- 确定对系统的综合要求
- 分析系统的数据要求
- 导出系统的逻辑模型
- 修正系统开发计划

#### 与用户沟通方式

- 访谈
- 面向数据流自顶向下求精
- 简易的应用规格说明技术
- 快速建立软件原型

#### 分析建模

建立三种模型：数据模型，功能模型，行为模型

- 数据模型—>**实体-联系图（实体，关系，属性）**：描绘数据对象、数据对象的属性及数据对象之间的关系，用于建立数据模型
- 功能模型—>**数据流图**：描绘当数据在软件系统中流动和被处理的逻辑过程，是建立功能模型的基础
- 行为模型—>**状态转换图**：描绘系统的状态及引起状态转换的事件，来表示系统的行为

<!--数据冗余：第一范式冗余最大：每个属性都是原子值；第二范式：满足第一范式，每个非关键字由整个关键字决定......-->

------

### -形式化说明技术

按形式化程度分为三类：

- 非形式化，如用**自然语言**描述规格说明
- 半形式化，如用数据流图或实体-联系图建立**模型**
- 形式化，如描述系统性质是基于**数学**的技术

三种形式化说明方法:

1. 有穷状态机（状态说明表格）
2. Petri网：便于描述**并发活动**（位置P，转化T，输入函数I，输出函数O）
3. Z语言（使用最广泛的形式化说明语言）

------

### -总体设计

#### 设计过程

系统设计（确定具体实现方案）+结构设计（确定软件结构）

9个主要步骤：

- 设想供选择的方案
- 选取合理的方案
- 推荐最佳方案
- 功能分解
- 设计软件结构
- 设计数据库
- 制定测试计划
- 书写文档
- 审查和复审

#### 设计原理*

##### 模块化

​		就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。

##### 抽象

​		抽出事物本质特性而暂时不考虑细节。

##### 逐步求精（细化过程）

​		为了能集中精力解决最主要问题而尽量推迟对问题细节的考虑。逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术的基础。

​		**抽象和逐步求精是互补的。**

##### 信息隐藏（封装）

​		应该这样设计和确定模块，使得一个模块内包含的信息对于不需要这些信息的模块来说是不能访问的。

##### 局部化（局部性原理）

​		是指把一些关系密切的软件元素物理地址放得彼此靠近。

##### 模块独立

​		是模块化、抽象、信息隐藏和局部化的概念的直接结果。独立的程度测量标准：内聚、耦合。

##### 		耦合：模块之间的依赖紧密关系

- 数据耦合：如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据。数据耦合是低耦合
- 控制耦合：传递的信息中有控制信息。中等耦合，增加了系统的复杂性
- 特征耦合：当整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时
- 公共环境耦合：当两个或多个模块通过一个公共数据环境互相作用时。公共环境可以是全程变量、共享通信区、内存的公共覆盖区、任何存储介质的文件、物理设备等。
- 内容耦合：如果发生之一就是①一个模块访问另一个模块的内部数据,②一个模块不通过正常入口而转到另一个模块的内部,③两个模块有一部分程序代码重叠,④一个模块有多个入口。

##### 内聚：模块内部各个元素的依赖紧密关系

​	  1.**低内聚**

- 偶然内聚：如果一个模块完成一组任务，这些任务彼此之间有关系，关系也是很松散的。如在一个程序内有一组语句在两处或多处出现，于是把这些语句作为一个模块以节省内存

- 逻辑内聚：如果一个模块完成的任务在逻辑上属于相同或相似的一类。如一个模块产生各种类型的全部输出

- 时间内聚：如果一个模块包含的任务必须在同一时间内执行。如模块完成各种初始化工作

  2.**中内聚**

- 过程内聚：如果一个模块内的处理元素是相关的，且必须以特定次序执行。如流程图确定模块的划分，得到的往往是过程内聚的模块

- 通信内聚：如果一个模块中所有元素都是用同一个输入数据和产生同一个输出数据

  3.**高内聚**

- 顺序内聚：如果一个模块内的处理元素和同一个功能密切相关，且这些处理必须顺序执行。如一个处理元素的输出数据作为下一个处理元素的输入数据，根据数据流图划分模块得到往往是顺序内聚模块

- 功能内聚：如果模块内的所有处理元素属于一个整体，完成单一的功能

|   名称   | 得分 |
| :------: | :--: |
| 功能内聚 |  10  |
| 顺序内聚 |  9   |
| 通信内聚 |  7   |
| 过程内聚 |  5   |
| 时间内聚 |  3   |
| 逻辑内聚 |  1   |
| 偶然内聚 |  0   |

#### 描述软件结构的图形工具

##### 层次图

​		描绘软件的层次结构，和前面的层次方框图形式相同。一个矩形框代表一个模块，方框间的连线表示调用关系。

##### HIPO图（适合自顶向下）

​		“层次图加输入/处理/输出图”，就是在层次图的每个方框加编号。

##### 结构图

​		每个方框代表一个模块，框内注明模块的名字或主要功能，方框间的箭头（或直线）代表模块的调用关系，注释表示来回传递的信息【尾部空心圆表示传递数据，实心圆代表传递控制信息】

#### 面向数据流的设计方法（设计软件结构）

把信息流映射为软件结构，信息流的类型决定了软件的结构

**变换流**

信息从外部进入，经过变换中心加工处理后离开

**事物流**

事物进入，选取若干动作处理中的一个处理后离开

### -详细设计

结构化程序：仅通过顺序选择和循环三种基本控制结构进行连接，每个代码块只有一个入口和一个出口。

#### 过程设计的工具

##### 程序流程图（程序框图）

优点：对控制流程的描绘直观，初学者很容易掌握。

缺点：①程序流程图不是精益求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑全局结构②程序流程图中用箭头代表控制流 ，因此程序员不受任何约束，可以完全不顾结构程序设计的思想，随意转移③程序流程图不易表示数据结构。

##### 盒图（N-S图）

- 功能域明确
- 不可能任意转移控制
- 很容易确定局部和全局数据的作用域
- 很容易表现嵌套关系，也可以表示模块的层次结构

##### 问题分析图（PAD图）：二维树形结构

- 使用PAD符号设计出来必然是结构化程序
- PAD图描绘的程序结构十分清楚
- PAD图表现程序的逻辑，易读、易懂、易记
- 很容易将PAD图转化为高级语言程序
- 即可表示程序逻辑，也可表示数据结构
- PAD符号支持自动向下，逐步求精

##### 判定表：当算法中含有多重嵌套的条件选择时

- 优点：能清晰表示复杂的条件组合与应做的动作之间的关系
- 缺点：①判定表的含义不能一眼看出来②当数据元素多于两个时，判定表的简洁程度下降

##### 判定树：判定表变种

- 优点：一眼看出其含义，易于掌握，使用
- 缺点：①简洁性不如判定表，数据元素需重复写多遍②判定树的分支次序对画出的判定树的简洁程度有较大影响

#### 面向数据结构设计方法：根据数据结构设计程序处理方法

##### jackson图

顺序，选择，重复结构

Jackson方法

#### 定量度量程序的复杂程度

##### McCabe方法

McCabe根据程序控制流的复杂程度度量 程序的复杂程度，这样度量出的结果称为程序的环形复杂度。

①流图的表示：

- 结点：用圆表示，一个圆代表一条或多条语句
- 边：箭头线称为边，代表控制流
- 区域：由边和结点围成的面积 称为区域，当计算区域数时应该包括图外未被围起来的区域
- 判定结点：包含条件的结点

②计算环形复杂度的方法:

- 流图中线性无关的区域数等于环形复杂度
- 流图G的环形复杂度`V(G)=E-N+2`,其中E是流图中边的条数，N是结点数
- 流图G的环形复杂度`V(G)=P+1`,其中P是流图中判定结点的数目

##### Halstead方法

根据程序中运算符和操作数的总数来度量程序的复杂程度

### 实现（编码+测试）

#### 测试方法

1.白盒测试（结构测试）

程序看作透明的白盒，知道结构和处理算法，检测是否按照预期工作。

2.黑盒测试（功能测试）

不考虑内部结构和实现方式，测试接口看功能是否正常

#### 测试步骤

1. 模块测试（单元测试）
2. 子系统测试：模块组成一个子系统来测试，着重测试接口。
3. 系统测试（集成测试）：子系统装配为系统来测试。
4. 验收测试（确认测试）：用户参与。
5. 平行运行：对比新旧版本。

#### 单元测试

检测模块，常用于白盒测试，对一下5个方面检测：

1. 模块接口
2. 局部数据结构
3. 重要执行通路
4. 出错处理通路
5. 边界条件

#### 集成测试

渐增式（一个一个模块加入测试）和非渐增式（模块单独测试最后一起整合测试）

渐增式：

1. 自顶向下集成：从主控制模块开始，沿着程序的控制层次向下移动
2. 自底向上集成：从原子模块开始组装和测试

#### 确认测试

Alpha测试：用户在开发者的场所进行

Beta测试：软件的最终用户在多个场景下测试

#### 白盒测试

逻辑覆盖：根据内部结构穷举所有路径测试

基本路径测试：  1、画出控制流程图
							2、计算圈复杂度（环路复杂度）
							3、整理基本路径集合
							4、导出测试用例

#### 黑盒测试

等价划分：输入域划分为若干数据类，选取有代表性的导出测试用例。

边界值分析：对输入输出的边界值进行分析测试。

错误推测：根据经验和直觉列出特殊情况。

因果图：表明输入条件和输出结果的因果关系。

### 维护

就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程

​	   ①非结构化维护

- 如果软件配置的唯一成分是程序代码，那么维护活动从评价代码开始，而且由于内部文档不足而使评价更困难
- 非结构化维护需要付出巨大代价，是没有使用良好定义的方法学开发出来的必然结果
   ②结构化维护
- 如果有一个完整软件配置存在，那么维护从评价设计文档开始就很规范
- 减少精力的浪费，提高维护的总体质量

软件再工程过程：

![image-20200524154609041](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200524154609041.png)

------

## 面向对象方法学（对象+类+继承+通讯）

4个要点：

- 软件是由对象组成的，任何元素都是对象，复杂软件对向由比较简单的软件对象组成
- 所有对象都划分成对象类，类都定义了一组数据和一组方法
- 若干对象类组成一个层次的系统
- 对象间仅能通过传递消息互相联系

优点：

- 与人类习惯的思维方法一致
- 稳定性好
- 可重用性好
- 较易开发大型软件产品
- 可维护性好

### 对象模型（描述系统的数据结构）

静态结构

**类图（类与类之间的静态关系）**

定义类：三层长方形：类名，属性，服务

定义关系：

1. 关联：



### 动态模型（描述系统的控制结构）

### 功能模型（描述系统的功能）